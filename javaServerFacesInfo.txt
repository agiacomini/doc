#############################################################################################
#																							#
#	andr3a.giacomini@gmailcom																#
#																							#
#	Java Server Faces (JSF) http://www.javaserverfaces.org/									#
#																							#
#	URL: http://corejsf.com/																#
#		 https://www.oracle.com/technetwork/java/javaee/javaserverfaces-139869.html			#
#																							#
#############################################################################################

								Chapter 1:	GETTING START

La programmazione web con Servlet e JavaServer Pages (JSP) è poco intuitiva e molto tediosa.
La JavaServe Faces (JSF) invece promette di essere più friendly, permettendo ai programmatori
di pensare in termini di text fields e menu piuttosto che avere a che fare con "request parameters".

Story

	JSF Version						Release Date		Java EE Version

	- JSF 1.0 			 				2004				J2EE 1.4

	- JSF 1.1 ( bug fix release )

	- JSF 1.2 ( incremental release )  	2006 				Java EE 5
	
	- JSF 2.0 							2009				Java EE 6
	
	- JSF 2.2 ( la più recente )		2013				Java EE 7

Oggi JSF è il più eminente server-side Java web framework. E' possibile progettare interfacce utente 
mettendo i componenti in una form e collegandoli a degli oggetti Java, senza dover mixare codice
e markup ( <HTML> </HTML> ). Un punto di forza di JSF è il suo modello di componenti estendibile,
e un ampio numbero di componenti di terze parti che sono resi disponibili. Il desgin
flessibile del framework gli ha permesso di crescere e di adattarsi alle nuove tecnologie come Ajax.
Infine, a differenza delle altre tecnologie concorrenti, JSF supporta la separazione tra presentation
e business logic, navigazione, connessione con servizi esterni e gestione della configurazione.

JSF è costruito on top ( sopra ) alle Servlet e JSP, ma dal punto di vista dello sviluppatore JSF
queste tecnologie rappresentano solo l'insfrastruttura di basso livello.

Required Software

	- Java SE Software Development Kit ( JDK ) 5.0 o superiore
	- Application Server Support Java EE 7 ( che supporta JSF ) : Apache Tomcat 8 ( add JSF libraries ), GlassFish 4, JBoss Wildfly 8
	- Java IDE ( Integrated Development Environment ) : NetBeans, Eclipse IDE for Java EE Developers
	- JSF JAR files ( opzionale se si usa un Java IDE che integra automaticamente le API di JSF nel progetto );


//-------------------------------- Why JavaServer Faces? -----------------------------------------//

Esistono due tecniche popolari nello sviluppo di applicazioni web:

	- lo stile "rapd development", come Microsoft ASP.NET, in cui si usa un'ambiente di sviluppo visuale;
	
	- lo stile "hard-core coding", come Java EE (Java Enterpise Edition), in cui si scrive codice per supportare
	  un'applicazione backend ad alte prestazioni;
	  
Per i team di sviluppo la scelta è molto ardua. Java EE è una piattaforma altamente scalabile, portabile 
e multi piattaforma, supportata da molti vendor. Dall'altro lato ASP.NET rende facile creare interfacce 
utente attrattive/allettanti senza troppa programmazione tediosa. 
Naturalmente gli sviluppatori desiderano/vorrebbero entrambe gli aspetti: un back-end alte prestazioni e
una facile programmazione dell'interfaccia utente. 
La promessa di JSF è quella di portare ad un rapido sviluppo dell'interfaccia utente lato server Java.

In JSF si troverà gran parte dell'infrastruttura di basso livello che gli sviluppatori JSP devono implmentare
a mano, come la navigazione delle pagine e la validazione. Si può pensare alle Servlet e JSP come il linguaggio
"assemply" che sta sotto il cofano del framework JSF di alto livello.

JSF ha tre parti:

	- Un set ( insieme ) di componenti UI ( user interface ) prefabbricati;
	
	- Un modello di programmazione guidato dagli eventi ( event-driven );
	
	- Un modello di componenti che consente a sviluppatori di terze parti di fornire componenti addizionali
	
		- OpenFaces
		
		- RichFaces 
		
		- PrimeFaces
		
	
JSF è parte dello standard Java EE. JSF è incluso in ogni Server Applicativo Java EE, e può essere facilmente
aggiunto ad un web container standalone come Apache Tomcat.

	
//----------------------------------- Software Installation --------------------------------------//
	
Dal momento che JSF 1.2 è parte della specifica Java EE 5, il modo più semplice per provare JSF è usare un application
server che è compatibile con Java EE 5, per esempio "GlassFish" ( https://javaee.github.io/glassfish/download ).

In alternativa, è possibile anche usare un application server non completo di default della specifica Java EE 5 e di
conseguenza della specfica JSF 1.2. Un'esempio di questo caso è l'Apache Tomcat. Sarà necessario scaricare separatamente 
l'application server Tomcat e le librerie JSF. Di seguito un link utile con alcune indicazioni sulla procedura
da seguire ( http://horstmann.com/bigj2/tomcat-jsf.html ).


//-------------------------------------- A simple Example ----------------------------------------//

Questo esempio descrive una pagina di login ed è rappresentato essenzialmente da un file HTML con alcuni 
tag addizionali.

Nome file: hello-world.xhtml

	<!DOCTYPE html>
	<html xmlns="http://www.w3.org/1999/xhtml"					|
		  xmlns:f="http://xmlns.jcp.org/jsf/core"				|	JSF UI Components ( componenti importati automaticamente )
		  xmlns:h="http://xmlns.jcp.org/jsf/html"				|
		  xmlns:a="http://xmlns.jcp.org/jsf/passthrough">		|
		  
		<h:head>
		  <title>Hello World - Input Form</title>
		</h:head>

		<h:body>
			
			<h:form>
				<h:inputText id="name" value="#{user.name}" a:placeholder="What's your name?"></h:inputText>
				<h:commandButton value="Submit" action="myresponse"/>
			</h:form>
			
		</h:body>

	</html>

Nome file: login/web/index.jsp ( Listato1-1 )

	<html>
		<%@ taglib uri="http://java.sun.com/jsf/core" prefix="f" %>
		<%@ taglib uri="http://java.sun.com/jsf/html" prefix="h" %>
		<f:view>
			<head>
				<title>A Simple JavaServer Faces Application</title>
			</head>
			<body>
				<h:form>
					<h3>Please enter your name and password.</h3>
					<table>
						<tr>
							<td>Name:</td>
							<td>
								<h:inputText value="#{user.name}"/>
							</td>
						</tr>
						<tr>
							<td>Password:</td>
							<td>
								<h:inputSecret value="#{user.password}"/>
							</td>
						</tr>
					</table>
					<p>
						<h:commandButton value="Login" action="login"/>
					</p>
				</h:form>
			</body>
		</f:view>
	</html>
	

Si noti che:

	- Un numero di tag standard HTML - "body", "table", ... ;
	
	- Alcuni tag hanno un "prefix" ( prefisso ), come f:view e h:inputText.
	  Queste librerie di tag JSF sono importati con il "taglib" in testa al file;
	
	- I campi di input sono collegati ( linked ) con le proprietà di un'oggetto. L'attributo value="#{user.name}"
	  dice all'implementazione JSF di collegare il campo testo con la proprietà "name" dell'oggetto "user";

Quando l'utente inserisce il "nome" e la "password", al click sul bottone "Login" viene visualizzata la pagina di "Welcome".

Nome file: login/web/welcome.jsp ( Listato1-3 )

	<html>
		<%@ taglib uri="http://java.sun.com/jsf/core" prefix="f" %>
		<%@ taglib uri="http://java.sun.com/jsf/html" prefix="h" %>

		<f:view>
			<head>
				<title>A Simple JavaServer Faces Application</title>
			</head>
			<body>
				<h:form>
					<h3>
						Welcome to JavaServer Faces,
						<h:outputText value="#{user.name}"/>!
					</h3>
				</h:form>
			</body>
		</f:view>
	</html>

*****************
** INGREDIENTS **
*****************
L'esempio precedente consiste in:

	- Un'insieme di pagine web:
		
		- Le pagine di "Login" ( index.jsp ) e "Welcome" ( welcome.jsp );
	
	- Un "managed bean" ( UserBean.java ) che gestisce i dati dell'utente ( "username" e "password" );
	  N.B: Un "bean" è una classe Java con i campi ( proprieta ) "name" e "password".
	  
	- Un file di configurazione che elenca le risorse bean e le regole di navigazione. Di default il file è chiamato "faces-config.xml";
	
	- Una serie di file per il "servelt container": 
	
		- "web.xml" ( web deployment descriptor );
		- "index.html" che reindirizzano l'utente al corretto URL della pagina di login;
	
Nome file: login/src/java/com/corejsf/UserBean.java ( Listato1-2 )
	
	package com.corejsf;

	public class UserBean 
	{
		private String name;
		private String password;

		// PROPERTY: name
		public String getName() { return name; }
		public void setName(String newValue) { name = newValue; }

		// PROPERTY: password
		public String getPassword() { return password; }
		public void setPassword(String newValue) { password = newValue; }
	}

*************************
** DIRECTORY STRUCTURE **
*************************
Un'applicazione JSF viene deploiata ( deploy ) come un file WAR: è un file zippato con estensione ".war" e 
una struttura di directory che segue il seguente standard:

	WEB_INF/
	|
	|_______ configuration files
	|_______ classes/
	|		 |
	|		 |______ class files
	|
	|_______ lib/
			 |
			 |______ library files
			 

La struttura delle directory del WAR file dell'esempio precedente:

	( folder )login.war
	|
	|_______ ( folder ) META_INF
	|					|_______ ( file ) MANIFEST.MF
	|
	|_______ ( folder ) WEB-INF
	|					|_______ ( folder ) classes
	|										|
	|										|_______ (folder) com
	|										|				  |
	|										|				  |_______ ( folder ) corejsf
	|										|									  |
	|										|									  |_______ ( file ) UserBean.class
	|										|
	|										|_______ ( file ) faces-config.xml
	|										|
	|										|_______ ( file ) web.xml
	|
	|_______ ( file ) index.html
	|
	|_______ ( file ) index.jsp
	|
	|_______ ( file ) welcome.jsp
	

La struttura del progetto Java in Eclipse prevede il codice sorgente contenuto nella directory "/src/java", mentre le pagine
JSF e i file di configurazione contenuti nella directory "web":

	( folder ) login
	|
	|_______ ( folder ) src
	|					|
	|					|_______ ( folder ) java
	|										|
	|										|_______ ( folder ) com
	|															|
	|															|_______ ( folder ) corejsf
	|																				|
	|																				|_______ ( file ) UserBean.java
	|
	|_______ ( folder ) web
						|
						|_______ ( file ) index.html
						|
						|_______ ( file ) index.jsp
						|
						|_______ ( file ) welcome.jsp
						|
						|_______ ( folder ) WEB-INF
											|
											|_______ ( file ) faces-config.xml
											|
											|_______ ( file ) web.xml
											


//------------------------------------ Sample Application Analysis -------------------------------//

Un'applicazione Web è costituita da due parti: il "presentation layer" e la "business logic".
Il "presentation layer" riguarda il look dell'applicazione e il look dell'applicazione viene determinato
dai tag HTML che specificano il layout, le immagini e altro. La "business logic" invece viene implementata dal 
codice Java che determina il comportamento dell'applicazione.

Alcune tecnologie Web mixano tag HTML e codice. Questo approccio però, pur sembrando facile da seguire per produrre
singoli file che contengono sia la parte grafica che la parte di business, non va bene per applicazioni complesse
in quando mixare codice e markup può portare a problemi futuri.

Per questo motivo per progettare applicazioni web professionali è importante "separare" la parte di presentazione 
da quella di business logic. 

In JSF il codice applicativo è contanuto nei bean mentre il design è contenuto nelle pagine web.


***********
** BEANS **
***********
Un Java Bean è una classe Java che espone proprietà e eventi ad un'ambiente come JSF. Una proprietà è un
valore di un certo tipo identificato da un nome ( variabile ) che può essere letta e/o scritta.
Il modo più semplice di definire una proprietà è usare una "naming convention standard" per i metodi che leggono
e scrivono, più comunemente conosciuti come "getter/setter convention".

	public class UserBean 
	{
		private String name;
		private String password;
	
		public String getName() { . . . }
		public void setName(String newValue) {. . . }
		public String getPassword() { . . . }
		public void setPassword(String newValue) { . . . }
		. . .
	}

Nelle applicazioni JSF i Beans vengono usati per tutti quei dati che necessitano di essere acceduti dalle pagine web.
I Beans sono il canale di comunicazione tra l'interfaccia utente e il backend dell'applicazione.


***************
** JSF PAGES **
***************
Le pagine JSF tipicamente hanno l'estensione ".jsp" o ".jsf" ( L'estensione ".jsp" richiede meno forzo per 
la configurazione ) anche se l'estensione delle pagine URLs è ".faces". Quando il browser richiede 
l'URL http://localhost:8080/login/index.faces l'estensione ".faces" dell'URL viene mappato sull'estensione ".jsp" e il 
servelt container carica la pagina ".jsp". Questo processo è conseguenza dell'implementazione della tecnologia 
JSF sopra ( on top ) a quella delle servelt.

Tornando all'esempio dimostrativo del "Listato 1-1" ( la pagina JSF di login ), la pagina inizia con i tag di dichiarazione
delle librerie:

	<%@ taglib uri="http://java.sun.com/jsf/core" prefix="f" %>
	<%@ taglib uri="http://java.sun.com/jsf/html" prefix="h" %>
	
	N.B: JSF 2.2 <html xmlns:f="http://xmlns.jcp.org/jsf/core" xmlns:h="http://xmlns.jcp.org/jsf/html">
	
L'implementazione JSF dinifisce due insiemi di tag. I tag HTML generano markup HTML specific.
Se si vuole usare una tecnologia client alternativa allora si devono usare differenti tag library. 
I tag "core" sono indipendenti dalla tecnologia di rendering ( di rappresentazione della pagina ), infatti il tag "f:view" 
viene usato sia per pagine HTML che per pagine che sono visualizzate via telefono cellulare.
E' possibile usare qualsiasi prefisso si voglia per i tag ( basta dichiarali all'inizio della pagina ):

	- f:view or faces:view
	- h:inputText or html:inputText
	
La pagina del "Listato 1-1" è molto simile ad un form HTML. Di seguito le differenze:

	- Tutti i tag JSF sono contenuti in un tag "f:view"
	- Invece di usare il tag HTML "form", si sono racchiusi tutti i componenti JSF in un tag "h:form";
	- Invece di usare i famigliare tag HTML "input", sono stati usati "h:inputText", "h:inputSecret" e "h:commandButton";

I valori dei campi di input sono stati legati alle proprietà ( campi/field ) del Bean Java "user":

	<h:inputText value="#{user.name}"/>
	
I delimitatori "#{}" saranno spiegati più avanti ( Capitolo 2 ) Syntax of Value Expression.

Quando la pagina viene visualizzata, il framework chiama il metodo "getName()" per ottenere il valore corrente della proprietà.
Quando invece la pagina viene submitted, il framework invoca il metodo "setName()" per settare/impostare il valore che l'utente
ha inserito. 

Il tag "h:commandButton" ha un'attributo "action", il cui valore viene usato quando si specificano le regole
di navigazione. Mentre invece l'attributo "value" specifica la stringa visualizzata sul bottone:

	<h:commandButton value="Login" action="login"/>

Nel Listato1-3 viene usato "h:outputText" per visualizzare il nome dell'utente che l'utente ha inserito nella pagina "login.jsp".


****************
** NAVIGATION **
****************
Una regola di navigazione indica all'implementazione JSF quale pagina far visualizzare al browser dopo che
un form è stato spedito/sottomesso.
Nell'esempio riportato sopra, quando l'utente fa click sul pulsante di login si vuole che la navigazione porti dalla pagina
"login.jsp" alla pagina "welcome.jsp". Questa regola di navigazione viene specificata nel file "faces-config.xml":

	<navigation-rule>
		<from-view-id>/index.jsp</from-view-id>
		<navigation-case>
			<from-outcome>login</from-outcome>
			<to-view-id>/welcome.jsp</to-view-id>
		</navigation-case>
	</navigation-rule>
	
Il valore di "from-outcome" match con l'attributo "action" del "command button" della pagina "index.jsp" ( Listato1-1 ).

	<h:commandButton value="Login" action="login"/>
	
Oltre alle regole di navigazione, il file "faces-config.xml" contiene anche la definizione dei bean usati. Di seguito la definizione 
del bean "user":

	<managed-bean>
		<managed-bean-name>user</managed-bean-name>
		<managed-bean-class>
			com.corejsf.UserBean
		</managed-bean-class>
		<managed-bean-scope>session</managed-bean-scope>
	</managed-bean>
	
Sarà possibile usare il nome del bean, "user", negli attributi dei componenti dell'interfaccia utente. Per esempio
la pagina "index.jsp" ( Listato1-1 ) contiene il tag:

	<h:inputText value="#{user.name}"/>
	
L'attributo "value" si riferisce alla proprietà "name" del bean "user".

Il tag "managed-bean-class" specifica invece la classe bean "com.corejsf.UserBean".
Infine lo "scope" del bean è settato a "session", che significa che l'oggetto bean "user" sarà disponibile per un solo utente
lungo tutta la navigazione delle pagine. Differenti utenti che usano la web application avranno differenti istanze
dello stesso oggetto bean. 

Nome file: login/web/WEB-INF/faces-config.xml ( Listato1-4 )

	<?xml version="1.0"?>
	<faces-config xmlns="http://java.sun.com/xml/ns/javaee"
				  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
				  http://java.sun.com/xml/ns/javaee/web-facesconfig_1_2.xsd"
				  version="1.2">
		<navigation-rule>
			<from-view-id>/index.jsp</from-view-id>
			<navigation-case>
				<from-outcome>login</from-outcome>
				<to-view-id>/welcome.jsp</to-view-id>
			</navigation-case>
		</navigation-rule>

		<managed-bean>
			<managed-bean-name>user</managed-bean-name>
			<managed-bean-class>com.corejsf.UserBean</managed-bean-class>
			<managed-bean-scope>session</managed-bean-scope>
		</managed-bean>
	</faces-config>
	
	
Nome file: login/web/WEB-INF/faces-config.xml ( JSF Version 2.2 )
	
	<?xml version="1.0"?>
	<faces-config xmlns="http://xmlns.jcp.org/xml/ns/javaee"
				  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
				  http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_2.xsd"
				  version="2.2">
		<navigation-rule>
			<from-view-id>/index.jsp</from-view-id>
			<navigation-case>
				<from-outcome>login</from-outcome>
				<to-view-id>/welcome.jsp</to-view-id>
			</navigation-case>
		</navigation-rule>

		<managed-bean>
			<managed-bean-name>user</managed-bean-name>
			<managed-bean-class>com.corejsf.UserBean</managed-bean-class>
			<managed-bean-scope>session</managed-bean-scope>
		</managed-bean>
	</faces-config>
	
***************************
** SERVLET CONFIGURATION **
***************************
Quando viene deployata un'applicazione JSF dentro ad un "Application Server" si deve fornire un file di
configurazione chiamato "web.xml". Fortunatamente, si può usare lo stesso file "web.xml" per più applicazioni JSF.

Nome file: login/web/WEB-INF/web.xml ( Listato1-5 )

	<?xml version="1.0"?>
	<web-app xmlns="http://java.sun.com/xml/ns/javaee"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
		http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
		version="2.5">
		
		<servlet>
			<servlet-name>Faces Servlet</servlet-name>
			<servlet-class>javax.faces.webapp.FacesServlet</servlet-class>
			<load-on-startup>1</load-on-startup>
		</servlet>
		
		<servlet-mapping>
			<servlet-name>Faces Servlet</servlet-name>
			<url-pattern>*.faces</url-pattern>
		</servlet-mapping>

		<welcome-file-list>
			<welcome-file>index.html</welcome-file>
		</welcome-file-list>
	</web-app>
	
L'unico aspetto da tener presente di questo file è "<servlet-mapping>". Tutte le pagine JSF sono processate da una speciale servlet che
è parte dell'implementazione JSF. Per assicurare che la corretta servlet venga attivata quando una pagine JSF viene richiesta, 
le URLs JSF hanno uno speciale formato. Nell'esempio precedente hanno un'estensione ".faces".

Non è possibile far puntare il browser direttamente a "http://localhost:8080/login/index.jsp" ma l'URL deve essere 
"http://localhost:8080/login/index.faces". Il servelt container dell'Application Server usa queste regole di mapping "<servlet-mapping>"
per attivare la servelet JSF, la quale sostituisce il suffisso ".faces" e carica la pagina ".jsp".


**********************
** THE WELCOME FILE **
**********************
Quando l'utente inserisce una directory URL come "http://localhost:8080/login" all'interno del browser l'application 
server carica automaticamente la pagina "index.jsp" quando presente. Sfortunatamente, questo meccanismo non funziona con la pagine JSF.
Per superare questo problema, è possibile fornire un file "index.html" che automaticamente redirect l'utente alla pagina JSF.

Nome File: login/web/index.html ( Listato1-6 )

	<html>
		<head>
			<meta http-equiv="Refresh" content= "0; URL=index.faces"/>
			<title>Start Web Application</title>
		</head>
		<body>
			<p>Please wait for the web application to start.</p>
		</body>
	</html>
	

Infine, è una buona idea specificare "index.html" come pagina "welcome" nel file "web.xml" all'interno dei tag "<welcome-file>" ( vedi Listato1-5 ).

NOTE: 

//--------------------------------- Development Environments for JSF -----------------------------//

INTEGRATED DEVELOPMENT ENVIRONMENTS

VISUAL BUILDER TOOLS

AUTOMATION OF THE BUILD PROCESS WITH ANT

//------------------------------------------ JSF Framework Service -------------------------------//

Il Framework JSF è responsabile dell'interazione con i device client, e fornisce gli strumenti per legare insieme la "visual presentation",
la logica applicativa e la business logic di una applicazione web. Comunque, lo scope di JSF è ristretto allo strato di presentazione.

( Figura 1-12 ) High-level overview of JSF Framework

La peristenza del DataBase, i Web service e le altre connessioni con il backend sono fuori dallo scope di JSF.
Di seguito i più importanti servizi che il Framework JSF fornisce:

	- Architettura "Model-View-Controller": 
	Tutte le applicazioni software permettono agli utenti di manipolare determinati dati,
	come carrelli della spesa, itinerari di viaggio o qualsiasi altro dato che viene richiesto in un particolare dominio.
	Questi dati sono chiamati "Model". Esattamente come un artista crea un dipinto di un modello, lo sviluppatore software
	produce una "Views" del modello dei dati. In una applicazione web, l'HTML viene usato per disegnare queste "Views".
	
	JSF connette la "View" con il "Model". Come si è visto, un componente view può essere legato alla proprietà di un oggetto, come

		<h:inputText value="#{user.name}"/>
		
	Inoltre, JSF opera come "Controller" che reagisce all'utente processando azioni e valutando eventi di cambio valore, indirizzandole al codice
	che aggiorna il modello o la vista. Per esempio, se si vuole invocare un metodo per controllare se all'utente è permesso
	accedere alla applicazione web viene usato il seguente tag JSF:
	
		<h:commandButton value="Login" action="#{user.check}"/>
		
	Quando l'utente clicca il bottone e il form viene sottomesso al server, l'implementazione JSF invoca il metodo "check" per il bean "user".
	Questo metodo può eseguire azioni arbitrarie per aggiornare il modello, e ritornare l'ID di navigazione della pagina da visualizzare
	successivamente all'elaborazione ( "Dynamic Navigation" - Chapter 3 ).
	
	Per questo il Framework JSF implementa la classica architettura "Model-View-Controller".
	
	- Data Conversion: 
	Gli utenti inseriscono i dati in un form come testo. Mentre invece gli oggetti di business vogliono dati come numeri, date o altri
	tipi di dato. JSF rende facile questo processo di conversione specificando e personalizzando le regole di conversione ( Chapter 6 ).
	
	- Validazione e gestione degli errori: 
	Con JSF è facile aggiungere regole di validazione per i campi come "required" o "number". Naturalmente, quando l'utente inserisce 
	un dato non valido, è possibile visualizzare messaggi di errore appropriati ( Chapter 6 ).
	
	- Internationalization: 
	JSF gestisce anche le questioni di internazionalizzazione quali la codifica dei caratteri e la selezione di pacchetti di risorse.
	
	- Custom component:
	Gli sviluppatori di componenti possono sviluppare componenti sofisticati che i progettisti delle pagine usano nelle loro pagine.
	
	- Alternative Renderers:
	Di default, JSF genera markup per pagine HTML. Ma è facile estendere il framework JSF per produrre markup per altri linguaggi di
	marcatura come WML e XUL.
	
	- Tool support:

//--------------------------------------------- Behind the Scene ---------------------------------//

Diamo uno sguardo dietro alle scene dell'applicazione di esempio. 
Il punto di partenza è quando l'utente dal browser si connette a "http://localhost:8080/login/index.faces". La servlet JSF inizializza il
codice JSF e legge la pagina "index.jsp". Questa pagina contiene tag come "f:form" e "h:inputText". Ognuno di questi tag ha associato una
classe "tag handler". Quando la pagina viene letta, i "tag handler" vengono eseguiti. I "tag handler" JSF collaborano tra di loro
per costruire un'albero dei componenti ( Figura 1-3 ).

														-------------
														|  UIForm	|
														-------------
												
									-------------		-------------		-----------------
									|	UIInput	|		|	UIInput	|		|	UICommand	|
									-------------		-------------		-----------------
	
L'albero dei componenti è una struttura dati che contiene oggetti Java per tutti gli elementi delle interfacce utente presenti nelle pagine JSF.
Per esempio i due oggetti Java "UIInput" corrispondono ai campi "h:inputText" e "h:inputSecret" presenti nel file JSF.

*********************
** RENDERING PAGES **
*********************
Successivamente, la pagina HTML viene renderizzata ( rappresentata ). Tutto il testo che non è un tag JSF viene ignorato. I tag "h:form", "h:inputText" e
"h:commandButton" vengono convertiti in tag HTML. Come si è appena discusso, ognuno di questi tag da origine ad un componente associato. Ognuno di questi
componenti ( che sono oggetti Java ) ha un suo "renderer" ( visualizzatore/rasppresentatore ) che produce l'output HTML, che riflette lo stato del componente. 
Per esempio, il "renderer" per il componente che corrisponde al tag "h:inputText" produce il seguente output:

	<input type="text" name="unique ID" value="current value"/>
	
Questo processo viene cbhiamato "encoding" ( codifica ). Il "renderer" dell'oggetto "UIInput" chiede al framework di cercare l'ID univoco e il valore corrente
dell'espressione "user.name". Di default, le stringhe ID vengono assegnate dal framework. Gli ID possono sembrare piuttosto randomici, come per esempio
"_id_id12:_id_id21".
La pagina codificata in stile HTML ( encoded ) viene spedita al browser, e il browser la visualizza.

( Figura 1-14 ) Encoding and decoding JSF pages

**********************
** DECODING REQUEST **
**********************
Dopo che la pagina è stata visualizzata dal browser, l'utente inserisce i valori nei campi del form e lo sottomette cliccando sul pulsante "Submit". 
Il browser allora spedisce di nuovo al server web i dati del form ( form data ), formattati come una richiesta POST. Questa richiesta ha uno speciale formato,
definito come parte del protocollo HTTP. La richiesta POST contiene l'URL della pagina contenente il form ( /login/index.faces ) e anche i dati del form.

Note:  L'URL della richiesta POST è la stessa della richiesta di rendering ( rappresentazione ) della pagina del form. La navigazione verso una 
	   nuova pagina avviene dopo che il form è stato sottomesso.
	   
I dati del form sono una stringa di coppie ID/valore, come la seguente:

	id1=me&id2=secret&id3=Login
	
Come parte della normale elaborazione / processo delle Servlet, i dati del form vengono posizionato in una "hash table" alla quale tutti i componenti possono accedere.
Successivamente, il JSF framework permette ad ognuno dei componenti di ispezionare questa "hash table" ( questo processo viene chiamato "decoding" ).
Ognuno dei componenti decide autonomamente come interpretare i dati del form.
Il form di "login" ha tre componenti ( oggetti ): - due oggetti "UIInput" che corrispondono ai campi di inserimento testo del form e 
- un'oggetto "UICommand" che corrisponde al bottone di "Submit" del form.

- I due componenti "UIInput" aggiornano le proprietà del bean referenziate dall'attributo "value": questo attributo invoca il metodo
setter passando i valore che l'utente ha fornito nel campo testuale del form.

- Il componente "UICommand" controlla se il pulsante è stato cliccato. Se così fosse, allora il componente attiva un "action event" per lanciare
l'azione "login" referenziata dal suo attributo "action". Quell'evento dice al gestore della navigazione di cercare qual'è la pagina successiva, "welcome.jsp".

Si è appena visto quali sono i due principali passi di processo del JSF framework: "encodind" ( codifica ) e "decoding" ( decodifica ).

******************************************************************
** THE LIFE CYCLE ( la Sequenza di processo o "ciclo di vita" ) **
******************************************************************
La specifica JSF definisce sei distinte fasi come mostrato in Figura 1-16 ( pagina 32 ). 

La fase di "Restore View" recupera l'albero dei componenti per la pagina richiesta se la pagina è già stata visualizzata in precedenza
altrimenti costruisce un nuvo albero dei componenti se la pagina viene visualizzata per la prima volta. Se la pagina è già stata precedentemente 
visualizzata tutti i componenti sono settati/impostati al loro precedente stato. Questo significa che JSF conserva automaticamente le informazioni
del form/modulo. Per esempio, quando l'utente inserisce dati non corretti che vengono rigettati/rifiutati durante la decodifica, gli stessi input
vengono visualizzati nuovamente in modo che l'utente possa correggerli.

Se la "request" non ha dati di interrogazione, l'implementazione JSF passa alla fase di "Render Response". Questo succede quando la pagina
viene visualizzata per la prima volta. 

Altrimenti la fase successiva è quella di "Apply Request Values". In questa fase, l'implementazione JSF itera sugli oggetti componente nell'albero
dei componenti. Ogni oggetto componente controlla quali valori della richiesta gli appartengono e li memorizza.

Nella fase di "Process Validation", i valori della stringa sottomessa/inviata come request ( submit ) sono convertiti in "variabili locali" 
le quali possono essere oggetti di qualsiasi tipo.  Quando si progetta una pagina JSF è possibile allegare validatori che eseguono controlli
di correttezza sui valori locali. Se la validazione viene superata, il JSF "life cycle" prosegue normalmente. Tuttavia, quando si verificano
errori di conversione o di validazione l'implementazione JSF invoca direttamente la fase di "Render Response", visualizzando nuovamente
la pagina corrente in modo che l'utente abbia un'altra possibilità di fornire gli input corretti.

Dopo che la conversione e la validazione hanno conlcuso il loro lavoro, si presume che sia sicuro aggiornare i dati del modello.
Durante la fase di "Update Model Values" le variabili locali vengono usate per aggiornare i bean che sono legati al componente. 

Nella fase di "Invoke Application" il metodo "action" del componente pulsante/bottone che ha causato l'invio del form verrà eseguito.
Restituisce una stringa di risultati che viene passata al gestore della navigazione ( navigation handler ), il quale cerca la pagina 
successiva. 

Infine, la fase "Render Response" codifica ( encode ) la risposta e la spedisce la browser. Quando un'utente sottomette un form, 
clicca su un link o altrimenti genera una nuova richiesta, tutto questo ciclo ricomincia da capo.

*****************************************************************************************************************************************
 
								Chapter 2:	MANAGED BEAN

Il tema centrale della progettazione di applicazioni web è la separazione della parte di "presentation" da quella di "business logic".
JSF usa i "Beans" per ottenere questa separazione. Le pagine JSF si riferiscono alle properità del bean, e la logica del
programma è contenuta all'interno del codice implementato sempre nel bean. Visto che i bean sono così fondamentali nella
programmazione JSF verranno trattati in modo approfondito.

La prima parte discuterà le caratterstiche essenziali dei bean che è necessario sapere. Sarà presentato un'esempio di 
implementazione del bean e per finire il resto del capitolo coprirà aspetti più tecnici circa la configurazione
e il valore delle espressioni. 


//--------------------------------------------- Definition of a Bean ---------------------------------//

Un Java Bean è un componente software riusabile che può essere manipolato. Vengono usati per una varietà di scopi.
A prima vista i bean sembrano essere simili ad un'oggetto. Inoltre i bean servono anche ad un'altro scopo.
Gli oggetti sono creati e manipolati dentro ad un programma Java quando il programma chiama il loro
costruttore e invoca i suoi metodi.

All'interno del contesto JSF si usano i bean ogni volta che è necessario collegare classi Java con le pagine web o con
file di configurazione. 
Si consideri l'applicazione "login" del capitolo 1 "GETTING START" ( A simple Example ). Un'istanza "UserBean" è configurata
nel file "faces-config.xml":

	<managed-bean>
		<managed-bean-name>user</managed-bean-name>
		<managed-bean-class>com.corejsf.UserBean</managed-bean-class>
		<managed-bean-scope>session</managed-bean-scope>
	</managed-bean>
	
Questo significa: costruire un'oggetto della classe "com.corejsf.UserBean", dargli il nome "user" e renderlo vivo per tutta
la durata della sessione - cioè per tutte le richieste che provengono dallo stesso client.

Una volta che il bean è stato definito può essere acceduto dai componenti JSF. Per esempio, il seguente campo di input legge e aggiorna 
la proprietà "password" del bean "user":

	<h:inputSecret value="#{user.password}"/>
	
Come si può vedere, lo sviluppatore JSF non ha bisogno di scrivere alcun codice per costruire e manipolare il bean.
L'implementazione JSF costruisce i beans secondo gli elementi ( tag ) "managed-bean" presenti nel file di configurazione "faces-config.xml".

In una applicazione JSF i bean sono comunemente usati per i seguenti scopi:

	- i componeneti dell'interfaccia utente;
	- legare insieme il comportamente di un form web ( "backing bean" );
	- oggetti di business le cui proprietà sono visualizzate su una pagina web;
	- servizi come una fonte di dati esterna che devono essere configurati al momento dell'assemblaggio dell'applicazione;
	
*********************
** BEAN PROPERTIES **
*********************
La classi bean necessitano di seguire specifiche convenzioni di programmazione per esporre le proprie caratterstiche che 
il tool in seguito potrà usare.
Le caratterstiche più importanti di un bean sono le proprietà che espone. Una "proprietà" è qualsiasi attributo del bean che ha:

	- un nome;
	- un tipo;
	- metodi getter/setter;

Per esempio, la classe "UserBean" del precedente capitolo 1 "GETTING START" ( A simple Example ) ha una proprietà di nome "password" e di
tipo "String". I metodo "getPassword()" e "setPassword()" accedono al valore della proprietà.

In Java una bean è semplicemente una classe che segue certe covenzioni di codifica ( coding ).

La specifica JavaBeans pone una singola richiesta affinchè una classe sia una classe bean: deve avere un costruttore public di default ( ciaoè senza argomenti ).
Inoltre, per definire le proprietà, il bean deve usare una "naming patter" per i metodi getter e setter.
Definire le proprietà con la "naming patter" è semplice e intuitivo. Si consideri la seguente coppia di metodi:

	- public T getFoo()
	
	- public void setFoo( T newValue )
	
La coppia di metodi corrisponde ai metodi read-write della proprietà di tipo T e di nome "foo". Se si ha solo il primo metodo, allora
la proprietà è solo "read-only". Se si ha solo il secondo metodo, la proprietà è "write-only".

I nomi e le firme dei metodi devono match con il patter precisamente. Il nome del metodo deve iniziare con "get" o "set".
Un metodo "get" non deve eavere parametri. Un metodo "set" deve avere un solo parametro e non deve ritornare valori. 
Una classe bean può avere anche altri metodi oltre ai metodi getter e setter, ma questi metodi non producono le proprietà del bean.

Si noti che il nome della proprietà è la forma "decapitalized" della parte del nome del metodo che segue il prefisso "get" o "set".
Per esempio, "getFoo" da origine ad una proprietà chiamata "foo", con la prima lettera trasformata in maiuscola. Inoltre, se le prime 
due lettere dopo il prefisso sono maiuscole, allora la prima lettera rimane tale. Per esempio, il nome di metodo "getURL" dinisce
una proprietà "URL" e non "uRL".

Per le proprietà di tipo "boolean", si ha la possibilità di scegliere il prefisso del nome del metodo che legge la proprietà.
Sia 

	- public boolean isConnected()
	
	- public boolean getConnected()
	
sono nomi di metodi validi per il metodo che legge la proprietà "connected". 

La specifica dei Java beans non dice nulla sul comportamento dei metodi "getter" e "setter". In molte situazioni, questi metodi manipolano
semplicemente un campo d'istanza. Ma possono anche svolgere operazioni più sofisticate, come la ricerca nel database, la conversione dei dati,
la convalida dei dati e così via.

Una classe bean può anche avere altri metodi oltre ai "getter" e "setter", ma naturalmente questi metodi non danno origine ad altre proprietà
del bean.

**********************
** VALUE EXPRESSION **
**********************
Molti componenti dell'interfaccia utente JSF hanno un'attribbuto "value" che consente di specificare un valore o di legarlo ( binding )
al valore di una proprietà del bean. Per esempio, è possibile specificare un valore diretto:

	<h:outputText value="Hello, World!"/>
	
Oppure è possibile specificare una "value expression":

	<h:outputText value="#{user.name}"/>
	
In molte situazioni, una "value expression" come "#{user.name}" descrive una proprietà. Si noti che l'espressione può essere usata
sia per leggere che per scrivere quando viene usata in un componente di input, come

	<h:inputText value="#{user.name}"/>
	
Il metodo "getter" della proprietà viene invocato quando il componente viene renderizzato ( rappresentato ). Il metodo "setter"
della proprietà viene invocato invece quando viene processata la risposta ( response ) diretta all'utente che ha fatto richiesta ( request ).


//--------------------------------------------- Message Bundles ---------------------------------//

Quando si implementa un'applicazione web, è una buona idea raccogliere tutte le stringhe di messaggi possibili in un'unica posizione.
Questo processo rende più facile mantenere la coerenza dei messaggi.
Si possono collezzionare tutti le stringhe di messaggi all'interno di un'unico file di proprietà:

	guessNext=Guess the next number in the sequence!
	answer=Your answer:
	
Salvarlo insieme a tutte le altre classi ( "com/corejsf/messages.properties" ) e posizionarlo e nomiralo come si vuole, basta che 
l'estensione del file sia ".properties".

E' possibile dichiarare il "message bundle" in due differenti modi. Il modo più semplice ( e più consigliato) è quello di includerre i seguenti elementi
nel proprio file di configurazione JSF "faces-config.xml":
	
	<application>
		<resource-bundle>
			<base-name>com.corejsf.messages</base-name>
			<var>msgs</var>
		</resource-bundle>
	</application>
	
Oppure è possibile aggiungere l'elemento "f:loadBundle" per ogni pagina JSF che necessità di accedere al "message bundle":

	<f:loadBundle basename="com.corejsf.messages" var="msgs"/>
	
In entrambi i casi i messaggi del bundle sono accedibili attraverso una mappa di variabili chiamata "msgs".

E' possibile successivamente ( dopo aver integrato il message bundle nel proprio progetto ) usare le "value expressione" per accedere
alle stringhe di messaggio:

	<h:outputText value="#{msgs.guessNext}"/>

*********************************
** MESSAGES WITH VARIABLE PART **
*********************************


//--------------------------------------------- A sample Application ---------------------------------//


//--------------------------------------------- Backing Beans ---------------------------------//


//--------------------------------------------- Bean Scopes ---------------------------------//


//--------------------------------------------- Configuring Beans ---------------------------------//


//--------------------------------------------- The Syntax of Value Expression ---------------------------------//
